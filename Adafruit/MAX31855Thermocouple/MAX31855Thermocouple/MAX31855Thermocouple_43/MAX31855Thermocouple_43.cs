/*
 * Corrected routine is from the excellent Adafruit article 'Maxim 31855 Thermocouple Linearization'
 * https://learn.adafruit.com/calibrating-sensors/maxim-31855-linearization which is part of an
 * excellent series of articles on Calibrating Sensors
 * https://learn.adafruit.com/calibrating-sensors/why-calibrate
 * While the Correction routine is interesting I'm not sure it really improves the accuracy 
 * significantly enough to justify its inclusion at the expense of exe size.  If increased accuracy
 * is needed then perhaps the MAX31856 might be a better choice instead of data being output in a 
 * signed 14-bit (0.25°C) with the MAX31855 the MAX31856 uses a 19-bit output (0.0078125°C), but 
 * of course increased accuracy usually means increased cost.
 */

//#define INCLUDECORRECTED

#undef INCLUDECORRECTED


using System;
using System.Threading;
using GT = Gadgeteer;
using GTM = Gadgeteer.Modules;
using GTI = Gadgeteer.SocketInterfaces;

namespace Gadgeteer.Modules.Adafruit
{
    /// <summary>
    ///     Adafruit Thermocouple Amplifier MAX31855 breakout board module for Microsoft .NET Gadgeteer
    ///     <para />
    ///     Wiring Connections
    ///     <para />
    ///     3Vo -- Gadgeteer Pin 1 (3.3V only)
    ///     <para />
    ///     GND -- Gadgeteer Pin 10 GND
    ///     <para />
    ///     DO -- Gadgeteer Pin 3
    ///     <para />
    ///     CLK -- Gadgeteer Pin 4
    ///     <para />
    ///     CS -- Gadgeteer Pin 5
    ///     <para />
    ///     Requires a Gadgeteer 'X' or 'Y' Socket
    /// </summary>
    public class MAX31855Thermocouple : Module
    {
        /// <summary>
        ///     Fault type.
        /// </summary>
        public enum Faults
        {
            /// <summary>
            ///     No faults detected.
            /// </summary>
            OK = 0,

            /// <summary>
            ///     Thermocouple is short-circuited to VCC.
            /// </summary>
            SHORT_TO_VCC = 1,

            /// <summary>
            ///     Thermocouple is short-circuited to GND..
            /// </summary>
            SHORT_TO_GND = 2,

            /// <summary>
            ///     Thermocouple is open (no connections).
            /// </summary>
            OPEN_CIRCUIT = 4,

            /// <summary>
            ///     Problem with thermocouple.
            /// </summary>
            GENERAL_FAULT = 5,

            /// <summary>
            ///     Out of temperature range.
            /// </summary>
            OUT_OF_RANGE = 6
        }

        private readonly GTI.DigitalOutput _clk;
        private readonly GTI.DigitalOutput _cs;
        private readonly GTI.DigitalInput _miso; //this is the do or data out pin on the breakout board
        private Faults _fault = Faults.OK;
        private double _internal;
        private double _temperature;
        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <param name="socketNumber">The socket that this module is plugged in to.</param>
        public MAX31855Thermocouple(int socketNumber)
        {
            Offset = 0.0;

            var socket = Socket.GetSocket(socketNumber, true, this, null);
            socket.EnsureTypeIsSupported(new[] {'X', 'Y'}, this);

            _miso = GTI.DigitalInputFactory.Create(socket, Socket.Pin.Three, GTI.GlitchFilterMode.Off,
                GTI.ResistorMode.PullUp, this);
            _clk = GTI.DigitalOutputFactory.Create(socket, Socket.Pin.Four, false, this);
            _cs = GTI.DigitalOutputFactory.Create(socket, Socket.Pin.Five, true, this);
        }

        /// <summary>Single point calibration offset in C.</summary>
        public double Offset { get; set; }

        /// <summary>Fault from last temperature request if any.</summary>
        /// <returns>Fault Type</returns>
        public Faults Fault
        {
            get { return _fault; }
        }

        /// <summary>The temperature as measured by the K type thermocouple (-200°C to +1350°C output in 0.25 degree increments).</summary>
        /// <returns>Temperature in Celsius</returns>
        public double TemperatureCelsius()
        {
            GetData();
            return _temperature + Offset;
        }

        /// <summary>The temperature as measured by the K type thermocouple (range -320°F to 2460°F in 0.45 degree increments).</summary>
        /// <returns>Temperature in Fahrenheit</returns>
        public double TemperatureFahrenheit()
        {
            GetData();
            if (double.IsNaN(_temperature))
                return double.NaN;

            return _temperature*1.8 + 32.0;
        }

        /// <summary>The internal cold-junction temperature (-40°C to +125°C in 0.0625 degree increments).</summary>
        /// <returns>Temperature in Celsius</returns>
        public double InternalCelsius()
        {
            GetData();
            return _internal;
        }

        /// <summary>The internal cold-junction temperature (range -40°F to 255°F in 0.1125 degree increments ).</summary>
        /// <returns>Temperature in Fahrenheit</returns>
        public double InternalFahrenheit()
        {
            GetData();

            if (double.IsNaN(_internal))
                return double.NaN;

            return _internal*1.8 + 32.0;
        }

        private void GetData()
        {
            UInt32 data = 0;

            _cs.Write(false); //set chip select to low to use chip
            Thread.Sleep(2);

            for (var i = 31; i >= 0; i--)
            {
                _clk.Write(true);
                Thread.Sleep(1);

                if (_miso.Read())
                    data |= (uint) (1 << i);

                _clk.Write(false);
                Thread.Sleep(1);
            }

            _cs.Write(true); //set cs to high as we are finished with it
            Thread.Sleep(2);

            //test data
            //data = 4032874752; //-250 -55
            //data = 0x64007F00; //1600 127
            //data = 0x3E80EC00; // 1000 -20
            //data = 0xFFF06490; //-1.0 100.5625
            //data = 0; // 0 0
            //data = 0xFFFCFFF0; // -0.25 0.0625
            //data = 0x00010001; // Open Fault
            //data = 0x00010002; // Short to GND
            //data = 0x00010004; // Short to VCC

            //process status bit 0-2
            switch (data & 0x07)
            {
                case 0x0:
                    _fault = Faults.OK;
                    break;
                case 0x1:
                    _fault = Faults.OPEN_CIRCUIT;
                    break;
                case 0x2:
                    _fault = Faults.SHORT_TO_GND;
                    break;
                case 0x4:
                    _fault = Faults.SHORT_TO_VCC;
                    break;
                default:
                    _fault = Faults.GENERAL_FAULT;
                    break;
            }

            if (_fault != Faults.OK)
            {
                _temperature = double.NaN;
                _internal = double.NaN;
            }
            else
            {
                data >>= 4; //trim off the status bits etc so we can get to the junction temperature data

                // process the 11 bits of junction temperature

                _internal = (data & 0x7FF)*0.0625;

                if ((data & 0x800) != 0) //check negative sign bit
                {
                    _internal += -128;
                }

                data >>= 14; //trim off everything except the thermocouple temperature

                _temperature = (data & 0x1FFF)*0.25;

                if ((data & 0x02000) != 0) //check negative sign bit
                {
                    _temperature += -2048;
                }
            }
        }

        #region CORRECTEDROUTINES

#if INCLUDECORRECTED

    /// <summary>
    ///     Corrected temperature reading for a K-type thermocouple
    ///     allowing accurate readings over an extended range
    /// </summary>
    /// <returns>Temperature in Celsius</returns>
        public double correctedCelsius()
        {
            GetData();

            var internalTemp = _internal; // Read the internal temperature of the MAX31855.
            var rawTemp = _temperature;

            // Read the temperature of the thermocouple. This temp is compensated for cold junction temperature.
            double thermocoupleVoltage = 0;
            double internalVoltage = 0;
            double correctedTemp = 0;

            // Check to make sure thermocouple is working correctly.
            if (Double.IsNaN(rawTemp))
            {
                _fault = Faults.GENERAL_PROBLEM;
                correctedTemp = Double.NaN;
            }
            else
            {
                // Steps 1 & 2. Subtract cold junction temperature from the raw thermocouple temperature.
                thermocoupleVoltage = (rawTemp - internalTemp)*0.041276; // C * mv/C = mV

                // Step 3. Calculate the cold junction equivalent thermocouple voltage.

                if (internalTemp >= 0)
                {
                    // For positive temperatures use appropriate NIST coefficients
                    // Coefficients and equations available from http://srdata.nist.gov/its90/download/type_k.tab

                    double[] c =
                    {
                        -0.176004136860E-01, 0.389212049750E-01, 0.185587700320E-04, -0.994575928740E-07,
                        0.318409457190E-09, -0.560728448890E-12, 0.560750590590E-15, -0.320207200030E-18,
                        0.971511471520E-22, -0.121047212750E-25
                    };

                    // Exponential coefficients. Only used for positive temperatures.
                    const double A0 = 0.118597600000E+00;
                    const double A1 = -0.118343200000E-03;
                    const double A2 = 0.126968600000E+03;


                    // From NIST: E = sum(i=0 to n) c_i t^i + a0 exp(a1 (t - a2)^2), where E is the thermocouple voltage in mV and t is the temperature in degrees C.
                    // In this case, E is the cold junction equivalent thermocouple voltage.
                    // Alternative form: C0 + C1*internalTemp + C2*internalTemp^2 + C3*internalTemp^3 + ... + C10*internaltemp^10 + A0*e^(A1*(internalTemp - A2)^2)
                    // This loop sums up the c_i t^i components.
                    for (var i = 0; i < c.Length; i++)
                    {
                        internalVoltage += c[i]*Math.Pow(internalTemp, i);
                    }
                    // This section adds the a0 exp(a1 (t - a2)^2) components.
                    internalVoltage += A0*Math.Exp(A1*Math.Pow((internalTemp - A2), 2));
                }
                else if (internalTemp < 0)
                {
                    // for negative temperatures
                    double[] c =
                    {
                        0.000000000000E+00, 0.394501280250E-01, 0.236223735980E-04 - 0.328589067840E-06,
                        -0.499048287770E-08, -0.675090591730E-10, -0.574103274280E-12, -0.310888728940E-14,
                        -0.104516093650E-16, -0.198892668780E-19, -0.163226974860E-22
                    };

                    // Below 0 degrees Celsius, the NIST formula is simpler and has no exponential components: E = sum(i=0 to n) c_i t^i
                    for (var i = 0; i < c.Length; i++)
                    {
                        internalVoltage += c[i]*Math.Pow(internalTemp, i);
                    }
                }

                // Step 4. Add the cold junction equivalent thermocouple voltage calculated in step 3 to the thermocouple voltage calculated in step 2.
                var totalVoltage = thermocoupleVoltage + internalVoltage;

                // Step 5. Use the result of step 4 and the NIST voltage-to-temperature (inverse) coefficients to calculate the cold junction compensated, linearized temperature value.
                // The equation is in the form correctedTemp = d_0 + d_1*E + d_2*E^2 + ... + d_n*E^n, where E is the totalVoltage in mV and correctedTemp is in degrees C.
                // NIST uses different coefficients for different temperature subranges: (-200 to 0C), (0 to 500C) and (500 to 1372C).
                if (totalVoltage < 0)
                {
                    // Temperature is between -200 and 0C.
                    double[] d =
                    {
                        0.0000000E+00, 2.5173462E+01, -1.1662878E+00, -1.0833638E+00, -8.9773540E-01, -3.7342377E-01,
                        -8.6632643E-02, -1.0450598E-02, -5.1920577E-04, 0.0000000E+00
                    };

                    for (var i = 0; i < d.Length; i++)
                    {
                        correctedTemp += d[i]*Math.Pow(totalVoltage, i);
                    }
                }
                else if (totalVoltage < 20.644)
                {
                    // Temperature is between 0C and 500C.
                    double[] d =
                    {
                        0.000000E+00, 2.508355E+01, 7.860106E-02, -2.503131E-01, 8.315270E-02, -1.228034E-02,
                        9.804036E-04,
                        -4.413030E-05, 1.057734E-06, -1.052755E-08
                    };

                    for (var i = 0; i < d.Length; i++)
                    {
                        correctedTemp += d[i]*Math.Pow(totalVoltage, i);
                    }
                }
                else if (totalVoltage < 54.886)
                {
                    // Temperature is between 500C and 1372C.
                    double[] d =
                    {
                        -1.318058E+02, 4.830222E+01, -1.646031E+00, 5.464731E-02, -9.650715E-04, 8.802193E-06,
                        -3.110810E-08, 0.000000E+00, 0.000000E+00, 0.000000E+00
                    };

                    for (var i = 0; i < d.Length; i++)
                    {
                        correctedTemp += d[i]*Math.Pow(totalVoltage, i);
                    }
                }
                else
                {
                    // NIST only has data for K-type thermocouples from -200C to +1372C. If the temperature is not in that range, set temp to impossible value.
                    // Error handling should be improved.
                    //Serial.print("Temperature is out of range. This should never happen.");
                    _fault = Faults.OUT_OF_RANGE;
                    correctedTemp = Double.NaN;
                }
            }
            return correctedTemp + Offset;
        }

        /// <summary>
        ///     Corrected temperature reading for a K-type thermocouple
        ///     allowing accurate readings over an extended range
        /// </summary>
        /// <returns>Temperature in Fahrenheit</returns>
        public double CorrectedFahrenheit()
        {
            var c = correctedCelsius();

            if (double.IsNaN(c))
                return double.NaN;

            return _temperature*1.8 + 32.0;
        }

#endif

        #endregion
    }
}